module.exports = {

"[externals]/ [external] (next/dist/compiled/next-server/app-route.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/next-server/app-route.runtime.dev.js");

module.exports = mod;
}}),
"[externals]/ [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("@opentelemetry/api");

module.exports = mod;
}}),
"[externals]/ [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/next-server/app-page.runtime.dev.js");

module.exports = mod;
}}),
"[externals]/ [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/server/app-render/work-unit-async-storage.external.js");

module.exports = mod;
}}),
"[externals]/ [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/server/app-render/work-async-storage.external.js");

module.exports = mod;
}}),
"[externals]/ [external] (mongoose, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("mongoose");

module.exports = mod;
}}),
"[externals]/ [external] (crypto, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("crypto");

module.exports = mod;
}}),
"[project]/src/app/lib/utils/StringValidator.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>StringValidators)
});
function StringValidators(value) {
    // Ensure the input is a string
    if (typeof value !== "string") {
        return false;
    }
    if (value === null) {
        return true;
    }
    // List of forbidden characters
    const charList = [
        '/',
        '\\',
        '"',
        ';',
        "'",
        '+',
        '`',
        '^'
    ];
    let validationFlag = true;
    // Iterate over each character in the list
    for (let char of charList){
        // Check if the forbidden character is present in the string
        if (value.includes(char)) {
            validationFlag = false;
            break; // Stop checking further once an invalid character is found
        }
    }
    return validationFlag;
}
}}),
"[project]/src/app/lib/models/Staffs.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "staffSchema": (()=>staffSchema)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__ = __turbopack_import__("[externals]/ [external] (mongoose, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/utils/StringValidator.js [app-route] (ecmascript)");
;
;
;
const staffSchema = new __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Schema({
    FirstName: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "First Name should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    LastName: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Last Name should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Address: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Address should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Contact: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Contact should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Email: {
        type: String,
        unique: true,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Email should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Password: {
        type: String,
        required: true,
        minlength: 6
    },
    SaltPassword: {
        type: String,
        required: true
    },
    DepartmentName: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Department Name should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Designation: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Designation should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Salary: {
        type: Number,
        default: 0.0
    },
    Incentive: {
        type: Number,
        default: 0.0
    },
    HotelId: {
        type: __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Schema.Types.ObjectId,
        ref: "Hotels"
    },
    Role: {
        type: String,
        required: true,
        enum: [
            'Owner',
            'Backoffice',
            'Waiter'
        ],
        default: 'Waiter',
        validate: {
            validator: (value)=>{
                return value === "Owner" || value === "Backoffice" || value === "Waiter";
            }
        },
        message: "Role should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    }
}, {
    timestamps: true
});
// Unique constraint on InvoiceId and ItemId
staffSchema.index({
    Contact: 1,
    HotelId: 1
}, {
    unique: true
});
staffSchema.index({
    Email: 1,
    HotelId: 1
}, {
    unique: true
});
// Instance methods
staffSchema.methods = {
    authenticate: async function(plainText) {
        return await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].compare(plainText, this.Password);
    }
};
// Pre-save hook to hash password
staffSchema.pre('save', async function(next) {
    try {
        if (this.isModified('Password')) {
            const salt = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].genSalt(10);
            this.Password = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(this.Password, salt);
            this.SaltPassword = salt;
        }
        next();
    } catch (error) {
        console.error('Error in pre-save hook:', error);
        next(error);
    }
});
// Pre-delete middleware for single document
staffSchema.pre('deleteOne', {
    document: true
}, async function(next) {
    try {
        const Bills = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Bills');
        // Check for active bills
        const activeBills = await Bills.find({
            WaiterId: this._id,
            Status: 'Open'
        });
        if (activeBills.length > 0) {
            throw new Error('Cannot delete staff with active bills');
        }
        // Run cleanup operations in parallel
        await Promise.all([
            Bills.deleteMany({
                WaiterId: this._id
            }),
            __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('StaffAttendance').deleteMany({
                StaffId: this._id
            })
        ]);
        next();
    } catch (error) {
        next(error);
    }
});
// Pre-delete middleware for multiple documents
staffSchema.pre('deleteMany', async function(next) {
    try {
        const Staffs = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Staffs');
        const Bills = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Bills');
        // Get staff members to be deleted
        const staffMembers = await Staffs.find(this.getFilter());
        if (staffMembers.length > 0) {
            const staffIds = staffMembers.map((staff)=>staff._id);
            // Check for active bills
            const activeBills = await Bills.find({
                WaiterId: {
                    $in: staffIds
                },
                Status: 'Open'
            });
            if (activeBills.length > 0) {
                throw new Error('Cannot delete staff members with active bills');
            }
            // Run cleanup operations in parallel
            await Promise.all([
                Bills.deleteMany({
                    WaiterId: {
                        $in: staffIds
                    }
                }),
                __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('StaffAttendance').deleteMany({
                    StaffId: {
                        $in: staffIds
                    }
                })
            ]);
        }
        next();
    } catch (error) {
        next(error);
    }
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].models.Staffs || __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model("Staffs", staffSchema);
}}),
"[project]/src/app/lib/utils/password.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "comparePassword": (()=>comparePassword),
    "hashPassword": (()=>hashPassword)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
;
const SALT_ROUNDS = 10;
const hashPassword = async (password)=>{
    try {
        const salt = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].genSalt(SALT_ROUNDS);
        const hashedPassword = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, salt);
        return {
            hashedPassword,
            salt
        };
    } catch (error) {
        console.error('Error hashing password:', error);
        throw error;
    }
};
const comparePassword = async (password, hashedPassword, salt)=>{
    try {
        // Hash the input password with the stored salt
        const hashedInput = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, salt);
        // Compare the hashed input with the stored hash
        return hashedInput === hashedPassword;
    } catch (error) {
        console.error('Error comparing passwords:', error);
        throw error;
    }
};
}}),
"[project]/src/app/lib/crud/BaseCrud.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "BaseCrud": (()=>BaseCrud)
});
class BaseCrud {
    constructor(model){
        this.model = model;
    }
    // Create a new document
    async create(data) {
        try {
            const doc = new this.model(data);
            await doc.save();
            return {
                returncode: 200,
                message: "Data Created Successfully",
                output: doc
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Read all documents with optional filters
    async readMany(filters = {}, options = {}) {
        try {
            const { sort = {}, populate = [], select = '', skip = 0, limit = 0, lean = false } = options;
            let query = this.model.find(filters);
            // Apply population
            if (populate.length > 0) {
                query = query.populate(populate);
            }
            // Apply sorting
            if (Object.keys(sort).length > 0) {
                query = query.sort(sort);
            }
            // Apply selection
            if (select) {
                query = query.select(select);
            }
            // Apply pagination
            if (skip > 0) {
                query = query.skip(skip);
            }
            if (limit > 0) {
                query = query.limit(limit);
            }
            // Execute query
            const docs = lean ? await query.lean() : await query.exec();
            return {
                returncode: 200,
                message: "Data Fetched Successfully",
                output: docs
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Read a single document
    async readOne(filters = {}, options = {}) {
        try {
            const { populate = [], select = '', lean = false } = options;
            let query = this.model.findOne(filters);
            // Apply population
            if (populate.length > 0) {
                query = query.populate(populate);
            }
            // Apply selection
            if (select) {
                query = query.select(select);
            }
            // Execute query
            const doc = lean ? await query.lean() : await query.exec();
            if (!doc) {
                return {
                    returncode: 404,
                    message: "Document Not Found",
                    output: []
                };
            }
            return {
                returncode: 200,
                message: "Data Fetched Successfully",
                output: doc
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Update a document
    async update(filters = {}, data = {}, options = {
        new: true
    }) {
        try {
            const doc = await this.model.findOneAndUpdate(filters, data, options);
            if (!doc) {
                return {
                    returncode: 404,
                    message: "Document Not Found",
                    output: []
                };
            }
            return {
                returncode: 200,
                message: "Data Updated Successfully",
                output: doc
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Delete a document
    async delete(filters = {}) {
        try {
            console.log('BaseCrud.delete called with:', {
                model: this.model.modelName,
                filters
            });
            const doc = await this.model.deleteMany(filters);
            console.log('BaseCrud.delete result:', doc);
            if (!doc || doc.deletedCount === 0) {
                console.log('BaseCrud.delete - No documents found');
                return {
                    returncode: 404,
                    message: "Document Not Found",
                    output: []
                };
            }
            return {
                returncode: 200,
                message: "Data Deleted Successfully",
                output: doc
            };
        } catch (error) {
            console.error('Error in BaseCrud.delete:', error);
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Check if document exists
    async exists(filters = {}) {
        try {
            const exists = await this.model.exists(filters);
            return {
                returncode: 200,
                message: exists ? "Document Exists" : "Document Not Found",
                output: !!exists
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: false
            };
        }
    }
    // Count documents
    async count(filters = {}) {
        try {
            const count = await this.model.countDocuments(filters);
            return {
                returncode: 200,
                message: "Count Retrieved Successfully",
                output: count
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: 0
            };
        }
    }
}
}}),
"[project]/src/app/lib/models/Hotels.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "HotelSchema": (()=>HotelSchema),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__ = __turbopack_import__("[externals]/ [external] (mongoose, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/utils/StringValidator.js [app-route] (ecmascript)");
;
;
const HotelSchema = new __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Schema({
    HotelName: {
        type: String,
        unique: true,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "HotelName should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Email: {
        type: String,
        unique: true,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Email should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Address: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "Address should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    Logo: {
        type: Buffer
    },
    Speciality: {
        type: [
            String
        ],
        default: []
    },
    Contacts: {
        type: [
            String
        ],
        default: []
    },
    Website: {
        type: String,
        default: "https://example.com"
    },
    FSSAICode: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "FSSAICode should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    },
    GSTIN: {
        type: String,
        required: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$StringValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "GSTIN should not contain invalid characters like /, \\, \", ;, ', +, `, or ^"
    }
}, {
    timestamps: true
});
// Add pre-remove middleware
HotelSchema.pre('remove', async function(next) {
    try {
        // Get all model references
        const Bills = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Bills');
        const Sections = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Sections');
        const MenuCategory = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('MenuCategory');
        const Suppliers = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Suppliers');
        const ItemCategories = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('ItemCategories');
        const Staffs = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Staffs');
        const Reservations = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Reservations');
        const CashDrawer = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('CashDrawer');
        const GstSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('GstSettings');
        const VatSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('VatSettings');
        const KotPrinterSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('KotPrinterSettings');
        const InvoicePrinterSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('InvoicePrinterSettings');
        const EbillEmailSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('EbillEmailSettings');
        // Delete all related data in parallel
        await Promise.all([
            // Delete Multi-level Operational Data
            Bills.deleteMany({
                HotelId: this._id
            }),
            Sections.deleteMany({
                HotelId: this._id
            }),
            MenuCategory.deleteMany({
                HotelId: this._id
            }),
            Suppliers.deleteMany({
                HotelId: this._id
            }),
            ItemCategories.deleteMany({
                HotelId: this._id
            }),
            Staffs.deleteMany({
                HotelId: this._id
            }),
            // Delete Single-level Operational Data
            Reservations.deleteMany({
                HotelId: this._id
            }),
            CashDrawer.deleteMany({
                HotelId: this._id
            }),
            // Delete settings
            GstSettings.deleteMany({
                HotelId: this._id
            }),
            VatSettings.deleteMany({
                HotelId: this._id
            }),
            KotPrinterSettings.deleteMany({
                HotelId: this._id
            }),
            InvoicePrinterSettings.deleteMany({
                HotelId: this._id
            }),
            EbillEmailSettings.deleteMany({
                HotelId: this._id
            })
        ]);
        next();
    } catch (error) {
        next(error);
    }
});
// Add pre-deleteMany middleware
HotelSchema.pre('deleteMany', async function(next) {
    try {
        // Get the hotels that will be deleted
        const Hotels = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Hotels');
        const hotels = await Hotels.find(this.getFilter());
        const hotelIds = hotels.map((hotel)=>hotel._id);
        if (hotelIds.length > 0) {
            // Multi-level
            const Bills = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Bills');
            const Sections = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Sections');
            const MenuCategory = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('MenuCategory');
            const Suppliers = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Suppliers');
            const Staffs = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Staffs');
            const Customers = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Customers');
            // Single-Level
            const Reservations = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Reservations');
            const CashDrawer = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('CashDrawer');
            const Expenses = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Expenses');
            // Delete settings
            const GstSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('GstSettings');
            const VatSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('VatSettings');
            const KotPrinterSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('KotPrinterSettings');
            const InvoicePrinterSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('InvoicePrinterSettings');
            const EbillEmailSettings = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('EbillEmailSettings');
            const Notifications = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Notifications');
            // Delete all related data in parallel
            await Promise.all([
                // Multi-level
                Bills.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                Sections.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                MenuCategory.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                Suppliers.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                Staffs.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                Customers.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                // Single-Level
                Reservations.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                CashDrawer.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                Expenses.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                // Delete settings
                GstSettings.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                VatSettings.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                KotPrinterSettings.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                InvoicePrinterSettings.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                EbillEmailSettings.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                }),
                Notifications.deleteMany({
                    HotelId: {
                        $in: hotelIds
                    }
                })
            ]);
        }
        next();
    } catch (error) {
        next(error);
    }
});
const Hotels = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].models.Hotels || __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model("Hotels", HotelSchema);
const __TURBOPACK__default__export__ = Hotels;
}}),
"[project]/src/app/lib/utils/BooleanValidator.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>BooleanValidator)
});
function BooleanValidator(value) {
    if (typeof value != "boolean") {
        return false;
    } else {
        return true;
    }
}
}}),
"[project]/src/app/lib/utils/SpecialStringsValidator.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "AttendanceValidator": (()=>AttendanceValidator),
    "ExpenseCategoryValidator": (()=>ExpenseCategoryValidator),
    "OrderTypeValidator": (()=>OrderTypeValidator),
    "PaymentModeValidator": (()=>PaymentModeValidator),
    "PaymentStatusValidator": (()=>PaymentStatusValidator),
    "StockStatusValidator": (()=>StockStatusValidator),
    "SubscriptionStatusValidator": (()=>SubscriptionStatusValidator),
    "TableStatusValidator": (()=>TableStatusValidator)
});
function SubscriptionStatusValidator(value) {
    let validation_flag = false;
    var list = [
        "Waiting",
        "On Going",
        "Expired",
        "About to Expire"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function PaymentStatusValidator(value) {
    let validation_flag = false;
    var list = [
        "Paid",
        "Unpaid",
        "Part-Paid"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function PaymentModeValidator(value) {
    let validation_flag = false;
    var list = [
        "Cash",
        "UPI",
        "Credit-Card",
        "Due",
        "Part"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function OrderTypeValidator(value) {
    let validation_flag = false;
    var list = [
        "Takeaway",
        "Delivery",
        "Dine-In",
        "Swiggy",
        "Zomato",
        "QR-Orders"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function TableStatusValidator(value) {
    let validation_flag = false;
    var list = [
        "Booked",
        "Bill Pending",
        "Open"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function StockStatusValidator(value) {
    let validation_flag = false;
    var list = [
        "Available",
        "Low Stock",
        "Unavailable"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function AttendanceValidator(value) {
    let validation_flag = false;
    var list = [
        "Absent",
        "Present",
        "Half-Day"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
function ExpenseCategoryValidator(value) {
    let validation_flag = false;
    var list = [
        "Salary",
        "Purchases",
        "Miscellaneous"
    ];
    list.map((item)=>{
        if (value === item) {
            validation_flag = true;
        }
    });
    return validation_flag;
}
}}),
"[project]/src/app/lib/models/HotelSubscription.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "HotelSubscriptionSchema": (()=>HotelSubscriptionSchema),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__ = __turbopack_import__("[externals]/ [external] (mongoose, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$BooleanValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/utils/BooleanValidator.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$SpecialStringsValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/utils/SpecialStringsValidator.js [app-route] (ecmascript)");
;
;
;
const HotelSubscriptionSchema = new __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Schema({
    HotelId: {
        type: __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Schema.Types.ObjectId,
        ref: "Hotels",
        required: true
    },
    SubscriptionId: {
        type: __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Schema.Types.ObjectId,
        ref: "Subscriptions",
        required: true
    },
    isValid: {
        type: Boolean,
        default: true,
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$BooleanValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(value)
        },
        message: "isValid should be either true or false"
    },
    StartDate: {
        type: String,
        required: true
    },
    EndDate: {
        type: String,
        required: true
    },
    Status: {
        type: String,
        default: "On Going",
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$SpecialStringsValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SubscriptionStatusValidator"])(value)
        },
        message: "Status must be one of:- 'Waiting', 'On Going', 'Expired', 'About to Expire'."
    },
    PaymentStatus: {
        type: String,
        default: "Paid",
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$SpecialStringsValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PaymentStatusValidator"])(value)
        },
        message: "Payment Status must be one of:- 'Paid', 'Unpaid', 'Part-Paid'."
    },
    PaymentMode: {
        type: String,
        default: "Cash",
        validate: {
            validator: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$SpecialStringsValidator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PaymentModeValidator"])(value)
        },
        message: "Payment Mode must be one of:- 'Cash', 'UPI', 'Credit-Card', 'Due', 'Part'."
    },
    Cash: {
        type: Number,
        default: 0.0
    },
    UPI: {
        type: Number,
        default: 0.0
    },
    CreditCard: {
        type: Number,
        default: 0.0
    }
}, {
    timestamps: true
});
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].models.HotelSubscription;
}}),
"[project]/src/app/lib/crud/HotelSubscription.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$models$2f$HotelSubscription$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/models/HotelSubscription.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$BaseCrud$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/crud/BaseCrud.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__ = __turbopack_import__("[externals]/ [external] (mongoose, cjs)");
;
;
;
class HotelSubscriptionCrud extends __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$BaseCrud$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseCrud"] {
    constructor(){
        super(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$models$2f$HotelSubscription$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]);
    }
    // Helper function to compare dates that could be in either format
    _compareDates(dateStr1, dateStr2) {
        try {
            // Try parsing as ISO format first
            const date1 = new Date(dateStr1);
            const date2 = new Date(dateStr2);
            // Check if both dates are valid in ISO format
            if (!isNaN(date1) && !isNaN(date2)) {
                return date1.getTime() - date2.getTime();
            }
            // If not ISO format, try parsing the custom format "DD Month YYYY"
            const parseCustomDate = (dateStr)=>{
                const [day, month, year] = dateStr.split(' ');
                const monthIndex = new Date(Date.parse(month + " 1, 2000")).getMonth();
                return new Date(parseInt(year), monthIndex, parseInt(day));
            };
            const customDate1 = parseCustomDate(dateStr1);
            const customDate2 = parseCustomDate(dateStr2);
            return customDate1.getTime() - customDate2.getTime();
        } catch (error) {
            console.error('Date comparison error:', error);
            return 0; // Return 0 if comparison fails
        }
    }
    // Helper function to check if a subscription is currently valid
    _isSubscriptionValid(subscription, currentDate) {
        try {
            const startDateCompare = this._compareDates(subscription.StartDate, currentDate);
            const endDateCompare = this._compareDates(subscription.EndDate, currentDate);
            return subscription.isValid && startDateCompare <= 0 && endDateCompare >= 0;
        } catch (error) {
            console.error('Subscription validation error:', error);
            return false;
        }
    }
    // Get hotels with valid subscriptions
    async getHotelsWithValidSubscription() {
        try {
            const currentDate = new Date().toLocaleDateString('en-GB', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
            // First get all subscriptions
            const allSubscriptions = await this.model.aggregate([
                {
                    $lookup: {
                        from: "hotels",
                        localField: "HotelId",
                        foreignField: "_id",
                        as: "hotel"
                    }
                },
                {
                    $unwind: "$hotel"
                }
            ]);
            // Filter and group valid subscriptions by hotel
            const validHotels = new Map();
            allSubscriptions.forEach((subscription)=>{
                const hotelId = subscription.HotelId.toString();
                if (this._isSubscriptionValid(subscription, currentDate)) {
                    // If we haven't seen this hotel before, or if this subscription is newer
                    if (!validHotels.has(hotelId) || this._compareDates(subscription.EndDate, validHotels.get(hotelId).EndDate) > 0) {
                        validHotels.set(hotelId, {
                            hotel: subscription.hotel,
                            EndDate: subscription.EndDate
                        });
                    }
                }
            });
            return {
                returncode: 200,
                message: "Successfully fetched hotels with valid subscriptions",
                output: Array.from(validHotels.values()).map((item)=>item.hotel)
            };
        } catch (error) {
            console.error('Error in getHotelsWithValidSubscription:', error);
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Get hotels with invalid or no subscriptions
    async getHotelsWithInvalidOrNoSubscription() {
        try {
            const currentDate = new Date().toLocaleDateString('en-GB', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
            // Get all subscriptions
            const allSubscriptions = await this.model.aggregate([
                {
                    $lookup: {
                        from: "hotels",
                        localField: "HotelId",
                        foreignField: "_id",
                        as: "hotel"
                    }
                },
                {
                    $unwind: "$hotel"
                }
            ]);
            // Keep track of hotels with valid and invalid subscriptions
            const validHotelIds = new Set();
            const invalidHotels = new Map();
            allSubscriptions.forEach((subscription)=>{
                const hotelId = subscription.HotelId.toString();
                if (this._isSubscriptionValid(subscription, currentDate)) {
                    validHotelIds.add(hotelId);
                    invalidHotels.delete(hotelId); // Remove from invalid if it was there
                } else if (!validHotelIds.has(hotelId)) {
                    // Only add to invalid if we haven't found a valid subscription for this hotel
                    if (!invalidHotels.has(hotelId) || this._compareDates(subscription.EndDate, invalidHotels.get(hotelId).EndDate) > 0) {
                        invalidHotels.set(hotelId, {
                            hotel: subscription.hotel,
                            EndDate: subscription.EndDate
                        });
                    }
                }
            });
            // Get hotels that don't have any subscription entries
            const allHotels = await __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].model('Hotels').find({
                _id: {
                    $nin: await this.model.distinct('HotelId')
                }
            });
            // Combine hotels with invalid subscriptions and hotels with no subscriptions
            const combinedResults = [
                ...Array.from(invalidHotels.values()).map((item)=>item.hotel),
                ...allHotels
            ];
            return {
                returncode: 200,
                message: "Successfully fetched hotels with invalid or no subscriptions",
                output: combinedResults
            };
        } catch (error) {
            console.error('Error in getHotelsWithInvalidOrNoSubscription:', error);
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Create
    async createHotelSubscription(data) {
        try {
            // Normalize field names to match schema
            const normalizedData = {
                HotelId: data.hotel_id,
                SubscriptionId: data.subscription_id,
                isValid: data.is_valid,
                StartDate: data.start_date,
                EndDate: data.end_date,
                PaymentStatus: data.payment_status,
                PaymentMode: data.payment_mode,
                Cash: data.cash,
                UPI: data.upi,
                CreditCard: data.credit_card
            };
            const result = await this.create(normalizedData);
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async readSubscription(hotel_id) {
        try {
            const result = await this.readMany({
                HotelId: hotel_id,
                isValid: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Subscription Payment
    async updateSubscriptionPayment(data) {
        try {
            const updateData = {
                isValid: true,
                PaymentStatus: data.payment_status,
                PaymentMode: data.payment_mode,
                Cash: data.cash,
                UPI: data.upi,
                CreditCard: data.credit_card
            };
            const hotel_subscription_id = data.hotel_subscription_id;
            const result = await this.update({
                _id: hotel_subscription_id
            }, updateData, {
                new: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Deactivate an account
    async deactivateAccount(data) {
        try {
            const updateData = {
                isValid: data.is_valid,
                Status: data.status
            };
            const hotel_subscription_id = data.hotel_subscription_id;
            const result = await this.update({
                _id: hotel_subscription_id
            }, updateData, {
                new: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Delete by Filter
    async deleteByFilter(filter) {
        const session = await __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].startSession();
        session.startTransaction();
        try {
            const result = await this.delete(filter);
            await session.commitTransaction();
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
}
const hotelSubscriptionCrud = new HotelSubscriptionCrud();
const __TURBOPACK__default__export__ = hotelSubscriptionCrud;
}}),
"[project]/src/app/lib/crud/Hotels.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$BaseCrud$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/crud/BaseCrud.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$models$2f$Hotels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/models/Hotels.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__ = __turbopack_import__("[externals]/ [external] (mongoose, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$HotelSubscription$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/crud/HotelSubscription.js [app-route] (ecmascript)");
;
;
;
;
class HotelsCrud extends __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$BaseCrud$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseCrud"] {
    constructor(){
        super(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$models$2f$Hotels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]);
    }
    // Create new Hotel with logo
    async createHotel(hotelData) {
        try {
            // Normalize field names to match schema
            const normalizedData = {
                HotelName: hotelData.hotel_name,
                Email: hotelData.email,
                Address: hotelData.address,
                Speciality: hotelData.speciality,
                Logo: hotelData.logo,
                Contacts: hotelData.contacts,
                Website: hotelData.website,
                FSSAICode: hotelData.fssai_code,
                GSTIN: hotelData.gstin
            };
            const result = await this.create(normalizedData);
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Update hotel logo
    async updateHotelLogo(hotel_id, logoData) {
        try {
            // Get existing hotel to delete old logo
            const result = await this.update({
                _id: hotel_id
            }, {
                Logo: logoData
            }, {
                new: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Read Hotel By ID 
    async readHotelByID(hotel_id) {
        try {
            const hotel = await this.readOne({
                _id: hotel_id
            });
            if (hotel.returncode !== 200) {
                return {
                    returncode: 401,
                    message: "Hotel doesn't exist",
                    output: []
                };
            }
            return hotel;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Read Hotel By Name
    async readHotelByName(hotel_name) {
        try {
            const hotel = await this.readOne({
                HotelName: hotel_name
            });
            if (!hotel) {
                return {
                    returncode: 401,
                    message: "Hotel doesn't exist",
                    output: []
                };
            }
            return hotel;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Check if hotel exists
    async doesHotelExists(hotel_name) {
        try {
            const hotel = await this.readOne({
                HotelName: hotel_name
            }, {});
            if (hotel.returncode !== 200) {
                return {
                    returncode: 401,
                    message: "Hotel doesn't exist",
                    output: []
                };
            }
            return hotel;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Read All Hotels
    async readAllHotels() {
        try {
            const hotels = await this.readMany({}, {
                sort: {
                    HotelName: 1
                },
                lean: true
            });
            return {
                returncode: 200,
                message: "Data fetched successfully",
                output: hotels.output
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Update Hotel Info
    async updateHotelInfo(hotelData) {
        try {
            const updateData = {
                HotelName: hotelData.hotel_name,
                Email: hotelData.email,
                Address: hotelData.address,
                Speciality: hotelData.speciality,
                Contacts: hotelData.contacts,
                Website: hotelData.website,
                FSSAICode: hotelData.fssai_code,
                GSTIN: hotelData.gstin
            };
            const result = await this.update({
                _id: hotelData.hotel_id
            }, updateData, {
                new: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Delete Hotel
    async deleteHotel(hotel_id) {
        try {
            // Extract ID from object if needed
            const id = typeof hotel_id === 'object' ? hotel_id.hotel_id : hotel_id;
            // Ensure hotel_id is a valid ObjectId
            if (!__TURBOPACK__imported__module__$5b$externals$5d2f$__$5b$external$5d$__$28$mongoose$2c$__cjs$29$__["default"].Types.ObjectId.isValid(id)) {
                return {
                    returncode: 400,
                    message: "Invalid hotel ID format",
                    output: []
                };
            }
            const hotel = await this.readOne({
                _id: id
            });
            if (!hotel) {
                return {
                    returncode: 404,
                    message: "Hotel not found",
                    output: []
                };
            }
            // Delete all related data in a transaction
            if (hotel.returncode === 200) {
                // Delete the Hotel
                await this.delete({
                    _id: id
                });
                return {
                    returncode: 200,
                    message: "Hotel deleted successfully",
                    output: []
                };
            }
            return {
                returncode: 400,
                message: "Hotel not Found",
                output: []
            };
        } catch (error) {
            return {
                returncode: 500,
                message: `Failed to delete hotel: ${error.message}`,
                output: []
            };
        }
    }
}
const hotelsCrud = new HotelsCrud();
const __TURBOPACK__default__export__ = hotelsCrud;
}}),
"[project]/src/app/lib/crud/Staffs.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$models$2f$Staffs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/models/Staffs.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$password$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/utils/password.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$BaseCrud$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/crud/BaseCrud.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$Hotels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/crud/Hotels.js [app-route] (ecmascript)");
;
;
;
;
class StaffCrud extends __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$BaseCrud$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseCrud"] {
    constructor(){
        super(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$models$2f$Staffs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]);
    }
    async createStaff(data) {
        try {
            const normalizedData = {
                FirstName: data.first_name,
                LastName: data.last_name,
                Address: data.address,
                Contact: data.contact,
                Email: data.email,
                Password: data.password,
                SaltPassword: 10,
                DepartmentName: data.department_name,
                Designation: data.designation,
                Salary: data.salary,
                Incentive: data.incentives,
                HotelId: data.hotel_id,
                Role: data.role
            };
            const result = await this.create(normalizedData);
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async login(email, password) {
        try {
            const staff = await this.readOne({
                Email: email
            });
            if (staff.returncode !== 200) {
                return {
                    returncode: 401,
                    message: "Staff doesn't exist",
                    output: []
                };
            }
            // Verify password
            const isValid = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$password$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["comparePassword"])(password, staff.output.Password, staff.output.SaltPassword);
            if (!isValid) {
                return {
                    returncode: 401,
                    message: 'Invalid credentials',
                    output: []
                };
            }
            // Get hotel information
            const hotel = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$Hotels$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].readHotelByID(staff.output.HotelId);
            if (!hotel) {
                return {
                    returncode: 404,
                    message: 'Associated hotel not found',
                    output: []
                };
            }
            // Return staff data with hotel information
            const userData = {
                hotelId: hotel.output._id,
                hotelName: hotel.output.HotelName,
                role: staff.output.Role,
                staff_info: staff.output
            };
            return {
                returncode: 200,
                message: 'Login successful',
                output: [
                    userData
                ]
            };
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async fetchStaffByHotelId(hotel_id) {
        try {
            const staff = await this.readMany({
                HotelId: hotel_id
            });
            if (staff.returncode !== 200) {
                return {
                    returncode: 401,
                    message: "Staffs doesn't exist",
                    output: []
                };
            }
            return staff;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async fetchStaffByEmail(email) {
        try {
            const staff = await this.readOne({
                Email: email
            });
            if (staff.returncode !== 200) {
                return {
                    returncode: 401,
                    message: "Staff doesn't exist",
                    output: []
                };
            }
            return staff;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    // Check if staff exists
    async doesStaffExists(first_name, last_name, contact) {
        try {
            const hotel = await this.readOne({
                FirstName: first_name,
                LastName: last_name,
                Contact: contact
            }, {});
            if (hotel.returncode !== 200) {
                return {
                    returncode: 401,
                    message: "Hotel doesn't exist",
                    output: []
                };
            }
            return hotel;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async updatePassword(data) {
        try {
            const updateData = {
                Password: data.hashedPassword,
                SaltPassword: data.salt
            };
            const result = await this.update({
                _id: data.staff_id
            }, updateData, {
                new: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async updateStaffInfo(data) {
        try {
            const updateData = {
                FirstName: data.first_name,
                LastName: data.last_name,
                Address: data.address,
                Contact: data.contact,
                Email: data.email,
                Password: data.password,
                DepartmentName: data.department_name,
                Designation: data.designation,
                Salary: data.salary,
                Incentive: data.incentives,
                Role: data.role
            };
            const result = await this.update({
                _id: data.staff_id
            }, updateData, {
                new: true
            });
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async deleteStaff(filter) {
        try {
            const result = await this.delete(filter);
            return result;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
    async deleteStaffById(staff_id) {
        try {
            // Finally, delete the staff itself
            const deleteResult = await this.delete({
                _id: staff_id
            });
            return deleteResult;
        } catch (error) {
            return {
                returncode: 500,
                message: error.message,
                output: []
            };
        }
    }
}
const staffCrud = new StaffCrud();
const __TURBOPACK__default__export__ = staffCrud;
}}),
"[project]/src/app/api/sync/Staffs/pull/controller.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "fetch_staff": (()=>fetch_staff)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$Staffs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/crud/Staffs.js [app-route] (ecmascript)");
;
async function fetch_staff(tokenData) {
    try {
        const hotel_id = await tokenData.hotelId;
        const existing_staffs = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$crud$2f$Staffs$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].fetchStaffByHotelId(hotel_id);
        if (existing_staffs.returncode === 404) {
            return {
                returncode: 409,
                message: "No Staffs to be displayed",
                output: []
            };
        }
        return existing_staffs;
    } catch (error) {
        return {
            returncode: 500,
            message: error.message,
            output: []
        };
    }
}
}}),
"[externals]/ [external] (buffer, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("buffer");

module.exports = mod;
}}),
"[externals]/ [external] (stream, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("stream");

module.exports = mod;
}}),
"[externals]/ [external] (util, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
const mod = __turbopack_external_require__("util");

module.exports = mod;
}}),
"[project]/src/app/lib/utils/jwt.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "createToken": (()=>createToken),
    "decodeToken": (()=>decodeToken),
    "updateToken": (()=>updateToken),
    "verifyToken": (()=>verifyToken)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'; // In production, always use environment variable
const JWT_EXPIRES_IN = '24h';
const createToken = (payload)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    });
};
const verifyToken = (token)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, JWT_SECRET);
    } catch (error) {
        return null;
    }
};
const updateToken = (token, newData)=>{
    try {
        const decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, JWT_SECRET);
        const updatedPayload = {
            ...decoded,
            ...newData
        };
        // Remove the exp claim to generate a fresh expiration
        delete updatedPayload.exp;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(updatedPayload, JWT_SECRET, {
            expiresIn: JWT_EXPIRES_IN
        });
    } catch (error) {
        return null;
    }
};
const decodeToken = (token)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].decode(token);
    } catch (error) {
        return null;
    }
};
}}),
"[project]/src/app/api/sync/Staffs/pull/route.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
__turbopack_esm__({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$api$2f$sync$2f$Staffs$2f$pull$2f$controller$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/api/sync/Staffs/pull/controller.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/src/app/lib/utils/jwt.js [app-route] (ecmascript)");
;
;
;
async function GET(request) {
    try {
        // Get token from cookie
        const token = request.cookies.get('hotel_auth_token')?.value;
        if (!token) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                returncode: 401,
                message: "No token provided",
                output: []
            }, {
                status: 401,
                statusText: "No token provided"
            });
        }
        // Verify the token
        const userData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$lib$2f$utils$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyToken"])(token);
        if (!userData) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                returncode: 401,
                message: "Invalid or expired token",
                output: []
            }, {
                status: 401,
                statusText: "Invalid or expired token"
            });
        }
        // Proceed with hotel fetch if token is valid
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$api$2f$sync$2f$Staffs$2f$pull$2f$controller$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetch_staff"])(userData);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            returncode: result.returncode,
            message: result.message,
            output: result.output
        }, {
            status: result.returncode
        });
    } catch (error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            returncode: 500,
            message: error.message,
            output: []
        }, {
            status: 500
        });
    }
}
}}),
"[project]/ (server-utils)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: require } = __turbopack_context__;
{
}}),

};

//# sourceMappingURL=%5Broot%20of%20the%20server%5D__e92e29._.js.map